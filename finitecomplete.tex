\section{Finite Complete Testing Theories for CSP}
\label{sec:finitecomplete}
% ==========================================================================
\subsection{A Model Map from CSP Processes to Finite State Machines}
\label{sec:mmap}

We will now construct a model map for associating CSP processes represented by normalised transition graphs to finite state machines. The intuition behind this 
construction is that the finite state machine's input alphabet  corresponds to
{\it sets of inputs} that may be offered to a CSP process. Depending on the events 
contained in this set, the process may (1) accept all of them, (2) accept some of them while refusing others, and (3) refuse all of them. This is reflected in the FSM
by output events that represent events that the process really has engaged in and 
an extra event $\bot$ representing deadlock, if the set of events has been refused.

More formally, we fix a finite CSP process alphabet $\Sigma$ and consider a 
finite-state process 
$P$ over this alphabet with normalised transition graph 
$G(P)=( N, \ii n, \Sigma, t : N\times\Sigma \pfun N, ac : N \fun \mathbb{P}\mathbb{P}(\Sigma))$,
 then the model map $T$ maps $P$ to the following observable FSM $T(P) = (Q,\ii q, \Sigma_I,\Sigma_O,h)$ satisfying
\begin{eqnarray*}
Q & = & N\cup \{\DL\} 
\\
\ii q & = & \ii n
\\
\Sigma_I & = & \power(\Sigma) - \{ \varnothing \}
\\
\Sigma_O & = & \Sigma \cup \{ \bot\}
\\
h & = & \{ (n,A,e,n')~|~A\in \Sigma_I \wedge e\in A \wedge 
(n,e)\in \dom~t\wedge t(n,e) = n' \} \cup {}
\\ & & 
\{ (n,A,\bot,\DL)~|~A\in \Sigma_I   \wedge 
\exists A'\in ac(n) \wedge A\cap A' = \varnothing
  \}
\end{eqnarray*} 

\begin{example}\label{ex:b}
For the CSP process $P$ and its transition graph $G(P)$ discussed in Example~\ref{ex:a}, the FSM $T(P)$ is depicted in Fig.~\ref{fig:fsm0}. 
For displaying its transitions, we used notation
$$
\forall A: \text{condition} / e
$$
which stands for a set of transitions between the respective nodes: one transition per non-empty set $A\subseteq \Sigma$ fulfilling the specified condition.
The arrow Node\_0 $\longrightarrow$ Node\_2 labelled by $\forall A: a\in A / a$, 
for example, stands for FSM transitions
$$
\begin{array}{l}
\text{Node\_0} \xrightarrow{\{a\}/a} \text{Node\_2} \\
\text{Node\_0} \xrightarrow{\{a,b\}/a} \text{Node\_2} \\
\text{Node\_0} \xrightarrow{\{a,c\}/a} \text{Node\_2} \\
\text{Node\_0} \xrightarrow{\{a,b,c\}/a} \text{Node\_2} \\
\end{array}
$$
\xbox
\end{example}


% ...................................................................................
 \begin{figure}
 %%\hspace*{-40mm}
 \begin{center}
\includegraphics[width=\textwidth]{fsm0.pdf}
\end{center}
%%\vspace*{-10mm}
\caption{FSM resulting from applying the model map to CSP process $P$ from Example~\ref{ex:a}.}
 \label{fig:fsm0}
 \end{figure}
% ................................................................................... 

We are now in the position to state and prove the theorem about the model map 
fulfilling the satisfaction condition {\bf SC1} introduced in Section~\ref{sec:transltt}. To this end, we first introduce three lemmas.



\begin{lemma}
Let $s\in \Sigma^*$ be any trace of $P$. Let $\underline n$ be the initial node of $G(P)$ and the initial state of $T(P)$. Let $n$ be the node of $G(P)$ denoting the process state $P/s$. Then for any input sequences $x\in \Sigma_I^*$ satisfying 
$\#x = \#s = k$   and $s(i)\in x(i)$, $\forall i\le k$, we have $x/s\in L(T(P))$ and $\underline n{\text{-after-}}x/s=n$. Furthermore,
for any $B\in \Sigma_I$, 
$$
B\in {\text{\rm Ref}}(P/s)\Leftrightarrow (x/s).(B/\bot) \in L(T(P))
$$

Conversely, any $x/s\in L(T(P))$ fulfils 
\begin{itemize}
\item[Case (1)] $s\in {\text {\rm tr}}(P)$ and $s(i)\in x(i), \forall i\le \#(x/s)$ \item[Case (2)] $x/s=(x'.x_k)/(s'.\bot)$ with $s'\in {\text {\rm tr}}(P)$, $s(i)\in x(i), \forall i< \#(x/s)$ and $x_k\in {\text{\rm Ref}}(P/s')$. 
\end{itemize}
\end{lemma}


From above we have straightforward the following lemmas
%----------------------------------------------------------------------------------
\begin{lemma}
For any $s\in \Sigma^*$, 
$$s\in {\text {\rm tr}}(P) \Leftrightarrow \exists x\in \Sigma_I^*: x/s \in L(T(P))$$
\end{lemma}
%-----------------------------------------------------------------------------

%--------------------------------------------------------------------------------
\begin{lemma}
For any $s\in \Sigma^*$ and $x_k\in \Sigma_I$, 
$$s\in {\text {\rm tr}}(P) \wedge  x_k\in {\text {\rm Ref}}(P/s)\Leftrightarrow \exists x\in \Sigma_I^*: x.x_k/s.\bot \in L(T(P))$$
\end{lemma}
%-------------------------------------------------------------------------------

\begin{theorem}
\label{th:sc1}
Consider the signature $Sig_1$ of CSP processes over fixed alphabet $\Sigma$ and the 
model map $T$ from CSP processes to finite state machines specified above.
Then
$$
\forall P, Q\in Sig_1: P \lessdet_F Q \Leftrightarrow   T(Q) \preceq T(P),
$$
where $\lessdet_F$ denotes failures refinement and $\preceq$ denotes reduction.
\end{theorem}
\begin{proof}
\[\begin{array}{lll}
T(Q)\le T(P) &\Leftrightarrow & L(T(Q))\subseteq L(T(P))\\
&\Leftrightarrow & \forall x/s\in L(T(Q))\Rightarrow x/s\in  L(T(P))\\
&\Leftrightarrow & \big(\forall x/s\in L(T(Q))\wedge s\in \Sigma^*\Rightarrow x/s\in  L(T(P))\wedge s\in \Sigma^* \big)\wedge\\
& &  \big(\forall x.x_k/s.\bot\in L(T(Q))\wedge s\in\Sigma^*\Rightarrow x.x_k/s.\bot\in  L(T(P))\wedge s\in\Sigma^*\big) \\
&\Leftrightarrow & \big(\forall s\in {\text {\rm tr}}(Q) \wedge \forall x/s\in L(T(Q))
 \Rightarrow  s\in {\text {\rm tr}}(P) \wedge   x/s\in L(T(P))\big)\wedge \\
& & \big(\forall s\in {\text {\rm tr}}(Q) \wedge\forall x/s\in L(T(Q))\wedge \forall x_k\in {\text {\rm Ref}}(Q/s)\setminus\{\varnothing\}\\&&{\phantom{\big(}}\Rightarrow  s\in {\text {\rm tr}}(P)\wedge  x/s\in L(T(P))\wedge  x_k\in {\text {\rm Ref}}(P/s)\setminus\{\varnothing\}\big) \\

&\Leftrightarrow & \big(\forall s\in {\text {\rm tr}}(Q) \Rightarrow  s\in {\text {\rm tr}}(P) \big) \wedge \\
& & \big(\forall s\in {\text {\rm tr}}(Q) \wedge \forall x_k\in {\text {\rm Ref}}(Q/s)\Rightarrow  s\in {\text {\rm tr}}(P) \wedge  x_k\in {\text {\rm Ref}}(P/s)\big) \\
&\Leftrightarrow &  \forall s\in {\text {\rm tr}}(Q)\Rightarrow s\in{\text {\rm tr}}(P) \wedge {\text {\rm Ref}}(Q/s)\subseteq {\text {\rm Ref}}(P/s)\\
&\Leftrightarrow & P\,\sqsubseteq_F\, Q

\end{array}
\]
\end{proof}
 

% ==========================================================================
\subsection{A Test Case Map from Finite State Machines to CSP Processes}
\label{sec:tcmap}

% -------------------------------------------------------------------------
\subsubsection*{FSM Test Cases}

Following~\cite{DBLP:conf/hase/PetrenkoY14}, 
an \emph{adaptive FSM test case} 
$$
tc_\text{FSM}=(Q,\ii q,\Sigma_I,\Sigma_O,h,in)
$$ 
is a nondeterministic, observable, output-complete, acyclic FSM which only provides a single input in a given state. Running in FSM intersection mode with the SUT, the test case provides a specific input to the SUT; this input is determined by the current state of the test case. It accepts every output and transits either to a fail-state FAIL, if the output is wrong according to the test objectives, or to the next test state uniquely determined  by the processed input/output pair. Another state PASS indicates that
the test has been completed without failure. Both FAIL and PASS are termination states, that is, they do not have any outgoing transitions.

Since the test case state determines the input for all of its outgoing transitions, this input is typically used as a state label, and the outgoing transitions are just labelled by the possible outputs. A function $in : Q -\{  \text{PASS}, \text{FAIL} \} 
\fun\Sigma_I$ maps the states to these inputs. Termination states
of the FSM are not labelled with further inputs.

\begin{example}
Consider the FSM test case depicted in Fig.~\ref{fig:fsm0tc} which is specified
for the same input and output alphabets as defined for  the FSM presented in Example~\ref{ex:b}. The test case is passed by the FSM from Example~\ref{ex:b}, because 
intersecting the two state machines results in an FSM which always reaches the PASS state.
\xbox
\end{example}


% ...................................................................................
 \begin{figure}
 %%\hspace*{-40mm}
 \begin{center}
\includegraphics[width=.8\textwidth]{fsm0tc.pdf}
\end{center}
%%\vspace*{-10mm}
\caption{An FSM test case which is passed by the FSM presented in Example~\ref{ex:b}.}
 \label{fig:fsm0tc}
 \end{figure}
% ................................................................................... 

 


% -------------------------------------------------------------------------
\subsubsection*{CSP Test Cases}
A \emph{CSP test case} is a terminating process with alphabet 
$\Sigma\cup\{\dag,\bot,\tick \}$, where the extra events stand for 
(1) test  verdict FAIL ($\dag$), (2) timeout ($\bot$), and (3) test 
 verdict PASS ($\tick$). In principle, very general classes of CSP processes can be
 used for testing, as introduced, for example, in~\cite{peleska_testing_1996,peleska1997a}. For the purpose of this paper, however, we can restrict the possible variants of CSP test cases to the ones that are in the range of the test case map which is constructed next.



% -------------------------------------------------------------------------
\subsubsection*{Test Case Map}

The test case map $T^* :TC(FSM) \fun TC(CSP)$ is specified with respect to a fixed
CSP process alphabet $\Sigma$ extended by the events $\{\dag,\bot,\tick \}$ introduced
above
and the associated FSM input and output alphabets
$\Sigma_I = \power(\Sigma)-\{\varnothing\}$ and $\Sigma_O=\Sigma\cup \{\bot \}$.
Given an FSM test case $tc_\text{FSM}=(Q,\ii q,\Sigma_I,\Sigma_O,h,in)$, 
the image $T^*(tc_\text{FSM})$ is the CSP process $tc_\text{CSP}$ specified 
as follows.
\begin{eqnarray*}
tc_\text{CSP} & = & tc(\ii q)
\\
tc(q) & = & \big( e : \{ a\in in(q)~|~h_1(q,in(q),e)\notin \{\text{PASS},\text{FAIL}\} \} \bullet e \then tc(h_1(q,in(q),e) \big)
\\ & & \extchoice
\\ & & \big( e : \{ a\in in(q)~|~h_1(q,in(q),e) = \text{PASS} \} \bullet e \then \tick \then \Skip \big)
\\ & & \extchoice
\\ & & \big( e : \{ a\in in(q)~|~h_1(q,in(q),e) = \text{FAIL} \} \bullet e \then \dag \then \Skip \big)
\end{eqnarray*}


% ..........................................................................
\begin{example}
The FSM test case $tc_\text{FSM}$
shown in Fig.~\ref{fig:fsm0tc} is mapped by $T^*$ to the following
CSP test case.
\begin{eqnarray*}
T^*(tc_\text{FSM}) & = & P_1
\\
P_1 & = & \big(e:\{ b,c,\bot \} \bullet e \then \dag\then\Skip\big)
\extchoice
 \big( a \then P_2 \big) 
\\
P_2 & = & \big( e : \{ a,b,\bot \}\bullet e\then \dag\then\Skip  \big)
\extchoice
\big( c\then P_3 \big)
\\
P_3 & = & \big( e : \{ a,b \}\bullet e\then \dag\then\Skip  \big)
\extchoice
\big( \bot \then P_4 \big)
\extchoice
\big( c\then P_5 \big)
\\
P_4 & = & \big( e : \{ b,c,\bot \}\bullet e\then \dag\then\Skip  \big)
\extchoice
\big( a\then\tick\then \Skip \big)
\\
P_5 & = & \big( e : \{ a,b,\bot \}\bullet e\then \dag\then\Skip  \big)
\extchoice
\big( c\then\tick\then \Skip \big)
\end{eqnarray*}
\xbox
\end{example}


% ==========================================================================


